# -*- coding: utf-8 -*-
"""
@Time ： 2022/8/30 20:01
@Auth ： 异世の阿银
@File ：test01.py
@IDE ：PyCharm
@Motto：ABC(Always Be Coding)
"""
'''
面向对象:一种思想, 将数据和行为捆绑在一起设计到指定的类中,未来可以使用这个类创造出对象,使用这个对象执行这个行为.

类与对象
# 请问: 类是什么? 类是抽象的说明, 可以理解成'模型' - '自定义的数据类型'
# 注意: 模型在定义的同时就要确定该模型创建出来的对象, 应该具备哪些数据与行为.
# 请问: 对象是什么?对象是类的具体体现.是可以存储数据和执行的行为的具体表示.

设计一个类:
类名
数据
行为
'''

'''
需求:设计一个Car类  所有类名首字母大写
1.类名 Car
2.数据 brand, color, wheel_number
3.行为 run()

# 面向对象的内存详解
'''



class Car:
    # 数据: 初始化数据的方法
    # 规范: 所有对象的数据全部都要写在init()方法中  (方法与函数非常相似, 函数直接调用, 方法必须使用对象才能调用)
    # init方法中的self这个参数不需要传递, 程序调用时会自动传递.
    # 创建模型时,可以设置数据的默认值,随后,创建对象时,拥有默认值的数据可以不传递参数.
    def __init__(self, brand, color, wheel_number=4):     # predefined预定义的
        # 实现数据赋值
        # 内部代码规范
        print(f'init self = {self}')
        # 思考: 以下三句代码实现了什么功能?
        # 将栈区中的数据存储到堆区中对应的对象空间内部.
        # 执行完这三句代码,堆区中的car1空间就有数据了.
        self.brand = brand  # 将局部变量存储到对象的堆区空间中 # 执行完init()方法会弹栈,局部变量会被销毁
        self.color = color
        self.wheel_number = wheel_number

    # 行为: 运行
    def run(self):
        # 行为的内部, 需要访问/ 使用的数据, 全部使用self.数据的方法来获取数据.
        # run()方法中的self 表示,谁调用该方法,该方法中的self就指向谁
        print(f'run self = {self}')
        print(f'{self.wheel_number}个轮子的{self.brand}牌,{self.color}的小轿车正在飞奔...')


if __name__ == '__main__':
    # 需求: 通过类名来创建不同的对象
    # 格式: 对象名称 = 类名(数据1, 数据2, 数据3) -> 底层会自动调用init()方法
    # 类名() 小括号是什么含义呢? 调用该类的init()方法

    # 创建第一个Car对象
    car1 = Car('兰博基尼', '金色', 5)     # self -> car1 -> 地址
    print(f'car1 = {car1}')
    # 执行对象的行为(使用)
    car1.run()                      # run是car1调用的, 所以self就是car1

    # 创建第二个Car对象
    car2 = Car('中国红旗', '红色')
    print(f'car2 = {car2}')
    # 执行对象的行为
    car2.run()                      # run是car2调用的, 所以self就是car2

# 问题: 为什么多个对象之间的数据不会产生混乱呢? 面向对象的思想具体是怎么实现数据的分类呢?
# 在内存中是怎么执行的?
'''
栈区stack : 
# 执行函数(面向过程), 方法(面向对象), 
# 入栈, 弹栈(默认最后有return语句)
# 先进后出
# 局部变量属于函数
堆区heap
# 存储对象的数据
# 只要对象存在,堆区中的对象数据就不会被销毁
# self表示当前对象在堆区中数据存储的地址
# 成员变量属于对象
代码区(code_zone)
# 类代码的存储
常量区
静态存储区

### 程序在内存中执行过程:
1. main主方法入栈
2. 当一个类第一次被使用时, 该类的设计代码会被存储到代码区中.
3. init()方法入栈  参数数据, 实参
4. 堆区中开辟空间存储对象的数据
5. init()方法弹栈
6. run()方法入栈
7. 从堆中取得数据
8. run()方法弹栈




代码区(code_zone)
作用: 存储类的设计代码
Car 类
1.对象数据
2.对象行为

堆区(heap)
作用:存储对象的数据
car1对象(本质就是内存中的一个地址)
'''
# 小括号一般都是用来调用方法的
# 类名() 调用该类的init()方法
# self 堆区中的内存空间(一个地址)

'''
init()方法是用来初始化数据的,当数据初始化完毕后,就会将改数据的内存地址空间返回的对象实现接收.
self 就是存储对象空间的地址

Constructor method 构造方法 init()  初始化
instance 对象/实例
实例方法/对象方法

'''

# 每一个对象在堆区中都有一块独立的空间, 对象之间的数据不会混乱

# init()方法被称为初始化方法, 主要是实现数据的初始化.(构造方法)
# 对象方法: 所有的对象方法,第一个默认参数都是self, 不能省略,不能删除, 有self作为第一个参数的方法,才被称为对象方法.
# 局部变量: 调用方法时,在参数上传递的数据,被称为局部变量,局部变量会随着方法的弹栈而销毁.
# 成员变量: self地址中存储的数据就被称为成员变量,成员指的是对象,成员变量也被称为对象变量,存储在堆区,堆区中的数据是不会弹栈销毁的,
# 如果一个对象没有任何引用了,Python的垃圾回收机制就会自动回收堆区中的空间,让出空间让其他对象继续使用.
# 成员还有一个名称叫'属性', 全称叫做'成员属性'
# 实例方法: 就是对象方法, 对象也被称为'实例对象'  instance / object

'''
面向对象有三大特性:
封装
继承
多态
'''

# 思考:函数和类有什么区别?
# 函数: 执行具体的功能
# 类: 数据 + 功能, 数据和功能是相互关联的.

# 举例: 学生对象
# name ='小明'  age = 18, gender = '男', 成绩= 80
# 数据: 姓名, 年龄
# 行为: 学习() -> 成绩+=1
#      旷课()  -> 成绩-=5
#      写作业() -> 成绩 += 1


'''
小结:
类其实就是一个更高级的'封装'体.将 数据 + 行为 进行打包 关联,
行为中操作对象的数据都是通过self关键字来实现的.
'''

